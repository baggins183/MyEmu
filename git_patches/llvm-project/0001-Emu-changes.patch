From bff0a759532654516970d10a17d22e54b2243496 Mon Sep 17 00:00:00 2001
From: Frodo Baggins <baggins31084@proton.me>
Date: Mon, 12 Feb 2024 20:35:21 -0800
Subject: [PATCH] Emu changes

AMDGPU disassembler: support CI (sea islands)
Add some mlir spirv instructions
---
 .../Disassembler/AMDGPUDisassembler.cpp       |  57 +++++-
 .../AMDGPU/Disassembler/AMDGPUDisassembler.h  |   7 +
 .../mlir/Dialect/SPIRV/IR/SPIRVBase.td        |  11 +-
 .../mlir/Dialect/SPIRV/IR/SPIRVGLOps.td       |  48 +++++
 .../mlir/Dialect/SPIRV/IR/SPIRVImageOps.td    | 177 ++++++++++++++++++
 5 files changed, 296 insertions(+), 4 deletions(-)

diff --git a/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp b/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp
index 05063c6c321a..c99944a7a425 100644
--- a/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp
+++ b/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp
@@ -50,7 +50,7 @@ AMDGPUDisassembler::AMDGPUDisassembler(const MCSubtargetInfo &STI,
       MAI(*Ctx.getAsmInfo()), TargetMaxInstBytes(MAI.getMaxInstLength(&STI)),
       CodeObjectVersion(AMDGPU::getDefaultAMDHSACodeObjectVersion()) {
   // ToDo: AMDGPUDisassembler supports only VI ISA.
-  if (!STI.hasFeature(AMDGPU::FeatureGCN3Encoding) && !isGFX10Plus())
+  if (!STI.hasFeature(AMDGPU::FeatureGCN3Encoding) && !isGFX10Plus() && !isCI())
     report_fatal_error("Disassembly not yet supported for subtarget");
 }
 
@@ -446,6 +446,45 @@ static inline DecoderUInt128 eat12Bytes(ArrayRef<uint8_t> &Bytes) {
   return DecoderUInt128(Lo, Hi);
 }
 
+// The disassembler is greedy, so we need to check FI operand value to
+// not parse a dpp if the correct literal is not set. For dpp16 the
+// autogenerated decoder checks the dpp literal
+static bool isValidDPP8(const MCInst &MI) {
+  using namespace llvm::AMDGPU::DPP;
+  int FiIdx = AMDGPU::getNamedOperandIdx(MI.getOpcode(), AMDGPU::OpName::fi);
+  assert(FiIdx != -1);
+  if ((unsigned)FiIdx >= MI.getNumOperands())
+    return false;
+  unsigned Fi = MI.getOperand(FiIdx).getImm();
+  return Fi == DPP8_FI_0 || Fi == DPP8_FI_1;
+}
+
+const char *llvm::getTableName(const uint8_t *Table) {
+  if (Table == DecoderTableAMDGPU32) { return "AMDGPU32"; }
+  //else if (Table == DecoderTableAMDGPU64) { return "AMDGPU64"; }
+  //else if (Table == DecoderTableDPP64) { return "DPP64"; }
+  //else if (Table == DecoderTableDPP864) { return "DPP864"; }
+  //else if (Table == DecoderTableDPP8GFX1164) { return "DPP8GFX1164"; }
+  //else if (Table == DecoderTableDPP8GFX1196) { return "DPP8GFX1196"; }
+  //else if (Table == DecoderTableDPPGFX1164) { return "DPPGFX1164"; }
+  //else if (Table == DecoderTableDPPGFX1196) { return "DPPGFX1196"; }
+  else if (Table == DecoderTableGFX1032) { return "GFX1032"; }
+  else if (Table == DecoderTableGFX1064) { return "GFX1064"; }
+  else if (Table == DecoderTableGFX10_B32) { return "GFX10_B32"; }
+  else if (Table == DecoderTableGFX10_B64) { return "GFX10_B64"; }
+  else if (Table == DecoderTableGFX1132) { return "GFX1132"; }
+  else if (Table == DecoderTableGFX1164) { return "GFX1164"; }
+  else if (Table == DecoderTableGFX1196) { return "GFX1196"; }
+  else if (Table == DecoderTableGFX664) { return "GFX664"; }
+  else if (Table == DecoderTableGFX6GFX732) { return "GFX6GFX732"; }
+  else if (Table == DecoderTableGFX6GFX764) { return "GFX6GFX764"; }
+  else if (Table == DecoderTableGFX732) { return "GFX732"; }
+  else if (Table == DecoderTableGFX764) { return "GFX764"; }
+  else if (Table == DecoderTableGFX832) { return "GFX832"; }
+  else if (Table == DecoderTableGFX864) { return "GFX864"; }
+  else { return "OTHER"; }
+}
+
 DecodeStatus AMDGPUDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
                                                 ArrayRef<uint8_t> Bytes_,
                                                 uint64_t Address,
@@ -487,6 +526,12 @@ DecodeStatus AMDGPUDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
     if (Bytes.size() >= 8) {
       const uint64_t QW = eatBytes<uint64_t>(Bytes);
 
+      if (isCI() && tryDecodeInst(DecoderTableGFX6GFX764, MI, QW, Address, CS))
+        break;
+
+      if (isCI() && tryDecodeInst(DecoderTableGFX764, MI, QW, Address, CS))
+        break;
+
       if (STI.hasFeature(AMDGPU::FeatureGFX10_BEncoding) &&
           tryDecodeInst(DecoderTableGFX10_B64, MI, QW, Address, CS))
         break;
@@ -510,7 +555,7 @@ DecodeStatus AMDGPUDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
           tryDecodeInst(DecoderTableGFX90A64, MI, QW, Address, CS))
         break;
 
-      if ((isVI() || isGFX9()) &&
+      if ((isCI() || isVI() || isGFX9()) &&
           tryDecodeInst(DecoderTableGFX864, MI, QW, Address, CS))
         break;
 
@@ -546,6 +591,12 @@ DecodeStatus AMDGPUDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
     if (Bytes.size() >= 4) {
       const uint32_t DW = eatBytes<uint32_t>(Bytes);
 
+      if (isCI() && tryDecodeInst(DecoderTableGFX6GFX732, MI, DW, Address, CS))
+        break;
+
+      if (isCI() && tryDecodeInst(DecoderTableGFX732, MI, DW, Address, CS))
+        break;
+
       if ((isVI() || isGFX9()) &&
           tryDecodeInst(DecoderTableGFX832, MI, DW, Address, CS))
         break;
@@ -1731,6 +1782,8 @@ bool AMDGPUDisassembler::isVI() const {
   return STI.hasFeature(AMDGPU::FeatureVolcanicIslands);
 }
 
+bool AMDGPUDisassembler::isCI() const { return AMDGPU::isCI(STI); }
+
 bool AMDGPUDisassembler::isGFX9() const { return AMDGPU::isGFX9(STI); }
 
 bool AMDGPUDisassembler::isGFX90A() const {
diff --git a/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.h b/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.h
index 2061d83af3da..fa834da4c734 100644
--- a/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.h
+++ b/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.h
@@ -21,6 +21,7 @@
 #include "llvm/MC/MCDisassembler/MCDisassembler.h"
 #include "llvm/MC/MCInst.h"
 #include "llvm/MC/MCInstrInfo.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/DataExtractor.h"
 #include <memory>
 
@@ -90,6 +91,8 @@ public:
 // AMDGPUDisassembler
 //===----------------------------------------------------------------------===//
 
+const char *getTableName(const uint8_t *Table);
+
 class AMDGPUDisassembler : public MCDisassembler {
 private:
   std::unique_ptr<MCInstrInfo const> const MCII;
@@ -144,6 +147,9 @@ public:
     if (Res != Fail) {
       MI = TmpInst;
       Comments << LocalComments;
+#if 0
+      llvm::outs() << "Decoded using " << getTableName(Table) << "\n";
+#endif
       return MCDisassembler::Success;
     }
     Bytes = SavedBytes;
@@ -268,6 +274,7 @@ public:
 
   const MCInstrInfo *getMCII() const { return MCII.get(); }
 
+  bool isCI() const;
   bool isVI() const;
   bool isGFX9() const;
   bool isGFX90A() const;
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
index 6ec97e17c5dc..b2143952e81b 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
@@ -4307,9 +4307,14 @@ def SPIRV_OC_OpCompositeConstruct         : I32EnumAttrCase<"OpCompositeConstruc
 def SPIRV_OC_OpCompositeExtract           : I32EnumAttrCase<"OpCompositeExtract", 81>;
 def SPIRV_OC_OpCompositeInsert            : I32EnumAttrCase<"OpCompositeInsert", 82>;
 def SPIRV_OC_OpTranspose                  : I32EnumAttrCase<"OpTranspose", 84>;
+def SPIRV_OC_OpImageFetch                 : I32EnumAttrCase<"OpImageFetch", 95>;
 def SPIRV_OC_OpImageDrefGather            : I32EnumAttrCase<"OpImageDrefGather", 97>;
+def SPIRV_OC_OpImageRead                  : I32EnumAttrCase<"OpImageRead", 98>;
+def SPIRV_OC_OpImageWrite                 : I32EnumAttrCase<"OpImageWrite", 99>;
 def SPIRV_OC_OpImage                      : I32EnumAttrCase<"OpImage", 100>;
+def SPIRV_OC_OpImageQuerySizeLod          : I32EnumAttrCase<"OpImageQuerySizeLod", 103>;
 def SPIRV_OC_OpImageQuerySize             : I32EnumAttrCase<"OpImageQuerySize", 104>;
+def SPIRV_OC_OpImageQueryLevels           : I32EnumAttrCase<"OpImageQueryLevels", 106>;
 def SPIRV_OC_OpConvertFToU                : I32EnumAttrCase<"OpConvertFToU", 109>;
 def SPIRV_OC_OpConvertFToS                : I32EnumAttrCase<"OpConvertFToS", 110>;
 def SPIRV_OC_OpConvertSToF                : I32EnumAttrCase<"OpConvertSToF", 111>;
@@ -4502,8 +4507,10 @@ def SPIRV_OpcodeAttr :
       SPIRV_OC_OpMemberDecorate, SPIRV_OC_OpVectorExtractDynamic,
       SPIRV_OC_OpVectorInsertDynamic, SPIRV_OC_OpVectorShuffle,
       SPIRV_OC_OpCompositeConstruct, SPIRV_OC_OpCompositeExtract,
-      SPIRV_OC_OpCompositeInsert, SPIRV_OC_OpTranspose, SPIRV_OC_OpImageDrefGather,
-      SPIRV_OC_OpImage, SPIRV_OC_OpImageQuerySize, SPIRV_OC_OpConvertFToU,
+      SPIRV_OC_OpCompositeInsert, SPIRV_OC_OpTranspose, SPIRV_OC_OpImageFetch,
+      SPIRV_OC_OpImageDrefGather, SPIRV_OC_OpImageRead, SPIRV_OC_OpImageWrite,
+      SPIRV_OC_OpImage, SPIRV_OC_OpImageQuerySizeLod, SPIRV_OC_OpImageQuerySize,
+      SPIRV_OC_OpImageQueryLevels, SPIRV_OC_OpConvertFToU,
       SPIRV_OC_OpConvertFToS, SPIRV_OC_OpConvertSToF, SPIRV_OC_OpConvertUToF,
       SPIRV_OC_OpUConvert, SPIRV_OC_OpSConvert, SPIRV_OC_OpFConvert,
       SPIRV_OC_OpConvertPtrToU, SPIRV_OC_OpConvertUToPtr,
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGLOps.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGLOps.td
index 3fcfb086f966..f3051ca8054f 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGLOps.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGLOps.td
@@ -1045,4 +1045,52 @@ def SPIRV_GLFindUMsbOp : SPIRV_GLUnaryArithmeticOp<"FindUMsb", 75, SPIRV_Int32>
   }];
 }
 
+def SPIRV_GLPackHalf2x16Op : SPIRV_GLUnaryArithmeticOp<"PackHalf2x16", 58, SPIRV_Integer, [Pure]> {
+  let summary = "test summary for UnpackHalf2x16";
+
+  let description = [{
+    test description
+  }];
+
+  let arguments = (ins
+    SPIRV_ScalarOrVectorOf<SPIRV_Float>:$operand
+  );
+
+  let results = (outs
+    SPIRV_Integer:$result
+  );
+}
+
+def SPIRV_GLUnpackHalf2x16Op : SPIRV_GLUnaryArithmeticOp<"UnpackHalf2x16", 62, SPIRV_ScalarOrVectorOf<SPIRV_Float>, [Pure]> {
+  let summary = "test summary for UnpackHalf2x16";
+
+  let description = [{
+    Result is the two-component floating-point vector with components obtained by unpacking
+    a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit
+    floating-point numbers according to the OpenGL Specification, and converting them to 32-bit
+    floating-point values. Subnormal numbers are either preserved or flushed to zero,
+    consistently within an implemenation.
+    The first component of the vector is obtained from the 16 least-significant bits of v;
+    the second component is obtained from the 16 most-significant bits of v.
+    The v operand must be a scalar with 32-bit integer type.
+    Result Type must be a vector of 2 components whose type is 32-bit floating point.
+  }];
+
+  let arguments = (ins
+    SPIRV_Integer:$operand
+  );
+
+  let results = (outs
+    SPIRV_ScalarOrVectorOf<SPIRV_Float>:$result
+  );
+}
+
+def SPIRV_GLExp2Op : SPIRV_GLUnaryArithmeticOp<"Exp2", 29, SPIRV_Float16or32> {
+  let summary = "Result is 2 raised to the x power; 2x.";
+
+  let description = [{
+    TODO desc
+  }];
+}
+
 #endif // MLIR_DIALECT_SPIRV_IR_GL_OPS
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVImageOps.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVImageOps.td
index 755d26de9d47..61db311a7a45 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVImageOps.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVImageOps.td
@@ -19,6 +19,104 @@ include "mlir/Interfaces/SideEffectInterfaces.td"
 
 // -----
 
+def SPIRV_ImageFetchOp : SPIRV_Op<"ImageFetch", [Pure]> {
+  let summary = "Fetch a single texel from an image whose Sampled operand is 1.";
+
+  let description = [{
+    Result Type must be a vector of four components of floating-point type or integer type. 
+    Its components must be the same as Sampled Type of the underlying
+    OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).
+
+    Image must be an object whose type is OpTypeImage. 
+    Its Dim operand must not be Cube, and its Sampled operand must be 1.
+
+    Coordinate must be a scalar or vector of integer type.
+    It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.
+
+    Image Operands encodes what operands follow, as per Image Operands.
+  }];
+
+  let availability = [
+    MinVersion<SPIRV_V_1_0>,
+    MaxVersion<SPIRV_V_1_6>,
+    Extension<[]>,
+    Capability<[]>
+  ];
+
+  let arguments = (ins
+    SPIRV_AnyImage:$image,
+    SPIRV_ScalarOrVectorOf<SPIRV_Integer>:$coordinate,
+    OptionalAttr<SPIRV_ImageOperandsAttr>:$imageoperands,
+    Variadic<SPIRV_Type>:$operand_arguments
+  );
+
+  let results = (outs
+    SPIRV_ScalarOrVectorOf<AnyTypeOf<[SPIRV_Integer, SPIRV_Float]>>:$result
+  );
+
+  let assemblyFormat = [{$image `:` type($image) `,`
+                         $coordinate `:` type($coordinate)
+                         custom<ImageOperands>($imageoperands)
+                         ( `(` $operand_arguments^ `:` type($operand_arguments) `)`)?
+                         attr-dict
+                         `->` type($result)}];
+
+  let hasVerifier = 0;
+}
+
+def SPIRV_ImageReadOp : SPIRV_Op<"ImageRead", [Pure]> {
+  let summary = "Read a texel from an image without a sampler.";
+
+  let description = [{
+    Result Type must be a scalar or vector of floating-point type or integer type. 
+    It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).
+
+    Image must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2.
+    If the Arrayed operand is 1, then additional capabilities may be required; e.g., ImageCubeArray, or ImageMSArray.
+
+    Coordinate must be a scalar or vector of floating-point type or integer type.
+    It contains non-normalized texel coordinates (u[, v] …​ [, array layer]) as needed by the
+    definition of Image. See the client API specification for handling of coordinates outside the image.
+
+    If the Image Dim operand is SubpassData, Coordinate is relative to the
+    current fragment location. See the client API specification for more detail on how these coordinates are applied.
+
+    If the Image Dim operand is not SubpassData, the Image Format must not be Unknown,
+    unless the StorageImageReadWithoutFormat Capability was declared.
+
+    Image Operands encodes what operands follow, as per Image Operands.
+  }];
+
+  let availability = [
+    MinVersion<SPIRV_V_1_0>,
+    MaxVersion<SPIRV_V_1_6>,
+    Extension<[]>,
+    Capability<[]>
+  ];
+
+  let arguments = (ins
+    SPIRV_AnyImage:$image,
+    SPIRV_ScalarOrVectorOf<AnyTypeOf<[SPIRV_Integer, SPIRV_Float]>>:$coordinate,
+    OptionalAttr<SPIRV_ImageOperandsAttr>:$imageoperands,
+    Variadic<SPIRV_Type>:$operand_arguments
+  );
+
+  let results = (outs
+    SPIRV_ScalarOrVectorOf<AnyTypeOf<[SPIRV_Integer, SPIRV_Float]>>:$result
+  );
+
+  let assemblyFormat = [{$image `:` type($image) `,`
+                         $coordinate `:` type($coordinate)
+                         custom<ImageOperands>($imageoperands)
+                         ( `(` $operand_arguments^ `:` type($operand_arguments) `)`)?
+                         attr-dict
+                         `->` type($result)}];
+
+  let hasVerifier = 0;
+}
+
+// -----
+
 def SPIRV_ImageDrefGatherOp : SPIRV_Op<"ImageDrefGather", [Pure]> {
   let summary = "Gathers the requested depth-comparison from four texels.";
 
@@ -133,6 +231,85 @@ def SPIRV_ImageQuerySizeOp : SPIRV_Op<"ImageQuerySize", [Pure]> {
   let assemblyFormat = "attr-dict $image `:` type($image) `->` type($result)";
 }
 
+def SPIRV_ImageQuerySizeLodOp : SPIRV_Op<"ImageQuerySizeLod", [Pure]> {
+  let summary = "Query the dimensions of Image for mipmap level for Level of Detail.";
+
+  let description = [{
+    Result Type must be an integer type scalar or vector. The number of components must be
+    1 for the 1D dimensionality,
+
+    2 for the 2D and Cube dimensionalities,
+
+    3 for the 3D dimensionality,
+
+    plus 1 more if the image type is arrayed. 
+    This vector is filled in with (width [, height] [, depth] [, elements]) where
+    elements is the number of layers in an image array, or the number of cubes in
+    a cube-map array.
+
+    Image must be an object whose type is OpTypeImage. Its Dim operand must be one of
+    1D, 2D, 3D, or Cube, and its MS must be 0. See OpImageQuerySize for querying image
+    types without level of detail.
+    See the client API specification for additional image type restrictions.
+
+  }];
+
+  let availability = [
+    MinVersion<SPIRV_V_1_0>,
+    MaxVersion<SPIRV_V_1_6>,
+    Extension<[]>,
+    Capability<[SPIRV_C_ImageQuery, SPIRV_C_Kernel]>
+  ];
+
+  let arguments = (ins
+    SPIRV_AnyImage:$image,
+    SPIRV_Integer:$lod
+  );
+
+  let results = (outs
+    SPIRV_ScalarOrVectorOf<SPIRV_Integer>:$result
+  );
+
+  let assemblyFormat = [{attr-dict $image `:` type($image) `,`
+                         $lod `:` type($lod) 
+                         `->` type($result)}];
+
+  let hasVerifier = 0;
+}
+
+def SPIRV_ImageQueryLevelsOp : SPIRV_Op<"ImageQueryLevels", [Pure]> {
+  let summary = "Query the number of mipmap levels accessible through Image.";
+
+  let description = [{
+    Result Type must be a scalar integer type.
+    The result is the number of mipmap levels,as specified by the client API.
+
+    Image must be an object whose type is OpTypeImage. 
+    Its Dim operand must be one of 1D, 2D, 3D, or Cube, and its
+    MS must be 0. 
+    See the client API specification for additional image type restrictions.
+  }];
+
+  let availability = [
+    MinVersion<SPIRV_V_1_0>,
+    MaxVersion<SPIRV_V_1_6>,
+    Extension<[]>,
+    Capability<[SPIRV_C_ImageQuery, SPIRV_C_Kernel]>
+  ];
+
+  let arguments = (ins
+    SPIRV_AnyImage:$image
+  );
+
+  let results = (outs
+    SPIRV_Integer:$result
+  );
+
+  let assemblyFormat = "attr-dict $image `:` type($image) `,` `->` type($result)";
+
+  let hasVerifier = 0;
+}
+
 // -----
 
 def SPIRV_ImageOp : SPIRV_Op<"Image",
-- 
2.45.0

